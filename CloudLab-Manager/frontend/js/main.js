import { errorRules } from "./errorRules.js";

const BACKEND_URL = "http://127.0.0.1:5000/analyze-error";

const analyzeBtn = document.getElementById("analyzeBtn");
const errorInput = document.getElementById("errorInput");
const explanation = document.getElementById("explanation");
const causes = document.getElementById("causes");
const solutions = document.getElementById("solutions");
const categoryBadge = document.getElementById("categoryBadge");

analyzeBtn.addEventListener("click", analyzeError);

async function analyzeError() {
  const input = errorInput.value.trim();
  if (!input) {
    alert("Please enter an error message");
    return;
  }

  // UI loading state
  analyzeBtn.textContent = "Analyzing...";
  analyzeBtn.classList.add("loading");
  analyzeBtn.disabled = true;

  explanation.textContent = "Analyzing error...";
  causes.innerHTML = "";
  solutions.innerHTML = "";

  // ðŸ”¥ STEP 1: Try OFFLINE RULES first
  for (const rule of errorRules) {
    if (rule.match.test(input)) {
      categoryBadge.textContent = "Rule-Based Offline";
      categoryBadge.className = "badge rule-based";

      explanation.textContent = rule.explanation;
      causes.innerHTML = rule.causes.map(c => `<li>${c}</li>`).join("");
      solutions.innerHTML = rule.solutions.map(s => `<li>${s}</li>`).join("");

      resetButton();
      return;
    }
  }

  // ðŸ”¥ STEP 2: Call BACKEND / GEMINI
  try {
    const res = await fetch(BACKEND_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ error: input })
    });

    const data = await res.json();
    if (!data.success) throw new Error("Backend failed");

    // ONLINE AI MODE
    if (data.source === "gemini") {
      categoryBadge.textContent = "Gemini AI (Online)";
      categoryBadge.className = "badge gemini";

      explanation.textContent =
        data.explanation ||
        "AI analyzed the error but did not return a clear explanation.";

      causes.innerHTML = data.causes?.map(c => `<li>${c}</li>`).join("")
        || "<li>Generated by AI</li>";

      solutions.innerHTML = data.solutions?.map(s => `<li>${s}</li>`).join("")
        || "<li>Follow the explanation above</li>";
    }

    // BACKEND RULE MODE
    else {
      categoryBadge.textContent = "Rule-Based Backend";
      categoryBadge.className = "badge rule-based";

      explanation.textContent = data.explanation;
      causes.innerHTML = data.causes.map(c => `<li>${c}</li>`).join("");
      solutions.innerHTML = data.solutions.map(s => `<li>${s}</li>`).join("");
    }

  } catch (err) {
    // ðŸ”¥ STEP 3: Graceful fallback
    categoryBadge.textContent = "Unknown Error";
    categoryBadge.className = "badge error";

    explanation.textContent =
      "This error could not be analyzed automatically. It may be new, uncommon, or environment-specific.";

    causes.innerHTML = `
      <li>Unsupported error pattern</li>
      <li>Backend server not running</li>
    `;

    solutions.innerHTML = `
      <li>Check full stack trace</li>
      <li>Search official documentation</li>
      <li>Add a new rule for this error</li>
    `;
  }

  resetButton();
}

function resetButton() {
  analyzeBtn.textContent = "Analyze Error";
  analyzeBtn.classList.remove("loading");
  analyzeBtn.disabled = false;
}
